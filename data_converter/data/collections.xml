<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/Users/khumoyunaminaddinov/PycharmProjects/Ai_inno/cpython/Doc/library/collections.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <section ids="module-collections collections-container-datatypes" names="collections\ ---\ container\ datatypes">
        <title>collections — Container datatypes</title>
        <index entries="['pair',\ 'module;\ collections',\ 'module-collections',\ '',\ None]"></index>
        <paragraph><strong>Source code:</strong> Lib/collections/__init__.py</paragraph>
        <comment groups="*" options="{}" testnodetype="testsetup" xml:space="preserve">from collections import *
import itertools
__name__ = '&lt;doctest&gt;'</comment>
        <transition></transition>
        <paragraph>This module implements specialized container datatypes providing alternatives to
            Python’s general purpose built-in containers, dict, list,
            set, and tuple.</paragraph>
        <table>
            <tgroup cols="2">
                <colspec colwidth="21"></colspec>
                <colspec colwidth="68"></colspec>
                <tbody>
                    <row>
                        <entry>
                            <paragraph>namedtuple()</paragraph>
                        </entry>
                        <entry>
                            <paragraph>factory function for creating tuple subclasses with named fields</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>deque</paragraph>
                        </entry>
                        <entry>
                            <paragraph>list-like container with fast appends and pops on either end</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>ChainMap</paragraph>
                        </entry>
                        <entry>
                            <paragraph>dict-like class for creating a single view of multiple mappings</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>Counter</paragraph>
                        </entry>
                        <entry>
                            <paragraph>dict subclass for counting hashable objects</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>OrderedDict</paragraph>
                        </entry>
                        <entry>
                            <paragraph>dict subclass that remembers the order entries were added</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>defaultdict</paragraph>
                        </entry>
                        <entry>
                            <paragraph>dict subclass that calls a factory function to supply missing values</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>UserDict</paragraph>
                        </entry>
                        <entry>
                            <paragraph>wrapper around dictionary objects for easier dict subclassing</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>UserList</paragraph>
                        </entry>
                        <entry>
                            <paragraph>wrapper around list objects for easier list subclassing</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>UserString</paragraph>
                        </entry>
                        <entry>
                            <paragraph>wrapper around string objects for easier string subclassing</paragraph>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
        <section ids="chainmap-objects" names="chainmap\ objects">
            <title>ChainMap objects</title>
            <versionmodified type="versionadded" version="3.3"><paragraph translatable="False">New in version 3.3.</paragraph></versionmodified>
            <paragraph>A ChainMap class is provided for quickly linking a number of mappings
                so they can be treated as a single unit.  It is often much faster than creating
                a new dictionary and running multiple update() calls.</paragraph>
            <paragraph>The class can be used to simulate nested scopes and is useful in templating.</paragraph>
            <index entries="['single',\ 'ChainMap\ (class\ in\ collections)',\ 'collections.ChainMap',\ '',\ None]"></index>
            <desc classes="py class" desctype="class" domain="py" noindex="False" objtype="class">
                <desc_signature class="" classes="sig sig-object py sig sig-object" fullname="ChainMap" ids="collections.ChainMap" module="collections"><desc_annotation xml:space="preserve">class<desc_sig_space classes="w w">  </desc_sig_space></desc_annotation><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">collections.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">ChainMap</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_operator classes="o o">*</desc_sig_operator><desc_sig_name classes="n n">maps</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>A ChainMap groups multiple dicts or other mappings together to
                        create a single, updateable view.  If no <emphasis>maps</emphasis> are specified, a single empty
                        dictionary is provided so that a new chain always has at least one mapping.</paragraph>
                    <paragraph>The underlying mappings are stored in a list.  That list is public and can
                        be accessed or updated using the <emphasis>maps</emphasis> attribute.  There is no other state.</paragraph>
                    <paragraph>Lookups search the underlying mappings successively until a key is found.  In
                        contrast, writes, updates, and deletions only operate on the first mapping.</paragraph>
                    <paragraph>A ChainMap incorporates the underlying mappings by reference.  So, if
                        one of the underlying mappings gets updated, those changes will be reflected
                        in ChainMap.</paragraph>
                    <paragraph>All of the usual dictionary methods are supported.  In addition, there is a
                        <emphasis>maps</emphasis> attribute, a method for creating new subcontexts, and a property for
                        accessing all but the first mapping:</paragraph>
                    <index entries="['single',\ 'maps\ (collections.ChainMap\ attribute)',\ 'collections.ChainMap.maps',\ '',\ None]"></index>
                    <desc classes="py attribute" desctype="attribute" domain="py" noindex="False" objtype="attribute">
                        <desc_signature class="ChainMap" classes="sig sig-object py sig sig-object" fullname="ChainMap.maps" ids="collections.ChainMap.maps" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">maps</desc_name></desc_signature>
                        <desc_content>
                            <paragraph>A user updateable list of mappings.  The list is ordered from
                                first-searched to last-searched.  It is the only stored state and can
                                be modified to change which mappings are searched.  The list should
                                always contain at least one mapping.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'new_child()\ (collections.ChainMap\ method)',\ 'collections.ChainMap.new_child',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="ChainMap" classes="sig sig-object py sig sig-object" fullname="ChainMap.new_child" ids="collections.ChainMap.new_child" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">new_child</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">m</desc_sig_name><desc_sig_operator classes="o o">=</desc_sig_operator>None</desc_parameter><desc_parameter xml:space="preserve"><desc_sig_operator classes="o o">**</desc_sig_operator><desc_sig_name classes="n n">kwargs</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Returns a new ChainMap containing a new map followed by
                                all of the maps in the current instance.  If m is specified,
                                it becomes the new map at the front of the list of mappings; if not
                                specified, an empty dict is used, so that a call to d.new_child()
                                is equivalent to: ChainMap({}, *d.maps). If any keyword arguments
                                are specified, they update passed map or new empty dict. This method
                                is used for creating subcontexts that can be updated without altering
                                values in any of the parent mappings.</paragraph>
                            <versionmodified type="versionchanged" version="3.4"><paragraph translatable="False">Changed in version 3.4: The optional m parameter was added.</paragraph></versionmodified>
                            <versionmodified type="versionchanged" version="3.10"><paragraph translatable="False">Changed in version 3.10: Keyword arguments support was added.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'parents\ (collections.ChainMap\ attribute)',\ 'collections.ChainMap.parents',\ '',\ None]"></index>
                    <desc classes="py attribute" desctype="attribute" domain="py" noindex="False" objtype="attribute">
                        <desc_signature class="ChainMap" classes="sig sig-object py sig sig-object" fullname="ChainMap.parents" ids="collections.ChainMap.parents" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">parents</desc_name></desc_signature>
                        <desc_content>
                            <paragraph>Property returning a new ChainMap containing all of the maps in
                                the current instance except the first one.  This is useful for skipping
                                the first map in the search.  Use cases are similar to those for the
                                nonlocal keyword used in nested scopes.  The use cases also parallel those for the built-in
                                super() function.  A reference to d.parents is equivalent to:
                                ChainMap(*d.maps[1:]).</paragraph>
                        </desc_content>
                    </desc>
                    <paragraph>Note, the iteration order of a ChainMap() is determined by
                        scanning the mappings last to first:</paragraph>
                    <paragraph>&gt;&gt;&gt; baseline = {'music': 'bach', 'art': 'rembrandt'}
&gt;&gt;&gt; adjustments = {'art': 'van gogh', 'opera': 'carmen'}
&gt;&gt;&gt; list(ChainMap(adjustments, baseline))
['music', 'art', 'opera']</paragraph>
                    <paragraph>This gives the same ordering as a series of dict.update() calls
                        starting with the last mapping:</paragraph>
                    <paragraph>&gt;&gt;&gt; combined = baseline.copy()
&gt;&gt;&gt; combined.update(adjustments)
&gt;&gt;&gt; list(combined)
['music', 'art', 'opera']</paragraph>
                    <versionmodified type="versionchanged" version="3.9"><paragraph translatable="False">Changed in version 3.9: Added support for | and |= operators, specified in <index entries="['single',\ 'Python\ Enhancement\ Proposals;\ PEP\ 584',\ 'index-0',\ '',\ None]"></index><target ids="index-0"></target><strong>PEP 584</strong>.</paragraph></versionmodified>
                </desc_content>
            </desc>
            <seealso>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>The MultiContext class<target ids="multicontext-class" names="multicontext\ class" refuri="https://github.com/enthought/codetools/blob/4.0.0/codetools/contexts/multi_context.py"></target>
                            in the Enthought CodeTools package<target ids="codetools-package" names="codetools\ package" refuri="https://github.com/enthought/codetools"></target> has options to support
                            writing to any mapping in the chain.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Django’s Context class<target ids="context-class" names="context\ class" refuri="https://github.com/django/django/blob/main/django/template/context.py"></target>
                            for templating is a read-only chain of mappings.  It also features
                            pushing and popping of contexts similar to the
                            new_child() method and the
                            parents property.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The Nested Contexts recipe<target ids="nested-contexts-recipe" names="nested\ contexts\ recipe" refuri="https://code.activestate.com/recipes/577434/"></target> has options to control
                            whether writes and other mutations apply only to the first mapping or to
                            any mapping in the chain.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A greatly simplified read-only version of Chainmap<target ids="greatly-simplified-read-only-version-of-chainmap" names="greatly\ simplified\ read-only\ version\ of\ chainmap" refuri="https://code.activestate.com/recipes/305268/"></target>.</paragraph>
                    </list_item>
                </bullet_list>
            </seealso>
            <section ids="chainmap-examples-and-recipes" names="chainmap\ examples\ and\ recipes">
                <title>ChainMap Examples and Recipes</title>
                <paragraph>This section shows various approaches to working with chained maps.</paragraph>
                <paragraph>Example of simulating Python’s internal lookup chain:</paragraph>
                <paragraph>import builtins
pylookup = ChainMap(locals(), globals(), vars(builtins))</paragraph>
                <paragraph>Example of letting user specified command-line arguments take precedence over
                    environment variables which in turn take precedence over default values:</paragraph>
                <paragraph>import os, argparse

defaults = {'color': 'red', 'user': 'guest'}

parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = {k: v for k, v in vars(namespace).items() if v is not None}

combined = ChainMap(command_line_args, os.environ, defaults)
print(combined['color'])
print(combined['user'])</paragraph>
                <paragraph>Example patterns for using the ChainMap class to simulate nested
                    contexts:</paragraph>
                <paragraph>c = ChainMap()        # Create root context
d = c.new_child()     # Create nested child context
e = c.new_child()     # Child of c, independent from d
e.maps[0]             # Current context dictionary -- like Python's locals()
e.maps[-1]            # Root context -- like Python's globals()
e.parents             # Enclosing context chain -- like Python's nonlocals

d['x'] = 1            # Set value in current context
d['x']                # Get first key in the chain of contexts
del d['x']            # Delete from current context
list(d)               # All nested values
k in d                # Check all nested values
len(d)                # Number of nested values
d.items()             # All nested items
dict(d)               # Flatten into a regular dictionary</paragraph>
                <paragraph>The ChainMap class only makes updates (writes and deletions) to the
                    first mapping in the chain while lookups will search the full chain.  However,
                    if deep writes and deletions are desired, it is easy to make a subclass that
                    updates keys found deeper in the chain:</paragraph>
                <paragraph>class DeepChainMap(ChainMap):
    'Variant of ChainMap that allows direct updates to inner scopes'

    def __setitem__(self, key, value):
        for mapping in self.maps:
            if key in mapping:
                mapping[key] = value
                return
        self.maps[0][key] = value

    def __delitem__(self, key):
        for mapping in self.maps:
            if key in mapping:
                del mapping[key]
                return
        raise KeyError(key)

&gt;&gt;&gt; d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': 'yellow'})
&gt;&gt;&gt; d['lion'] = 'orange'         # update an existing key two levels down
&gt;&gt;&gt; d['snake'] = 'red'           # new keys get added to the topmost dict
&gt;&gt;&gt; del d['elephant']            # remove an existing key one level down
&gt;&gt;&gt; d                            # display result
DeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'})</paragraph>
            </section>
        </section>
        <section ids="counter-objects" names="counter\ objects">
            <title>Counter objects</title>
            <paragraph>A counter tool is provided to support convenient and rapid tallies.
                For example:</paragraph>
            <paragraph>&gt;&gt;&gt; # Tally occurrences of words in a list
&gt;&gt;&gt; cnt = Counter()
&gt;&gt;&gt; for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:
...     cnt[word] += 1
...
&gt;&gt;&gt; cnt
Counter({'blue': 3, 'red': 2, 'green': 1})

&gt;&gt;&gt; # Find the ten most common words in Hamlet
&gt;&gt;&gt; import re
&gt;&gt;&gt; words = re.findall(r'\w+', open('hamlet.txt').read().lower())
&gt;&gt;&gt; Counter(words).most_common(10)
[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),
 ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]</paragraph>
            <index entries="['single',\ 'Counter\ (class\ in\ collections)',\ 'collections.Counter',\ '',\ None]"></index>
            <desc classes="py class" desctype="class" domain="py" noindex="False" objtype="class">
                <desc_signature class="" classes="sig sig-object py sig sig-object" fullname="Counter" ids="collections.Counter" module="collections"><desc_annotation xml:space="preserve">class<desc_sig_space classes="w w">  </desc_sig_space></desc_annotation><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">collections.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">Counter</desc_name><desc_parameterlist xml:space="preserve"><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">iterable-or-mapping</desc_sig_name></desc_parameter></desc_optional></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>A Counter is a dict subclass for counting hashable objects.
                        It is a collection where elements are stored as dictionary keys
                        and their counts are stored as dictionary values.  Counts are allowed to be
                        any integer value including zero or negative counts.  The Counter
                        class is similar to bags or multisets in other languages.</paragraph>
                    <paragraph>Elements are counted from an <emphasis>iterable</emphasis> or initialized from another
                        <emphasis>mapping</emphasis> (or counter):</paragraph>
                    <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; c = Counter()                           # a new, empty counter
&gt;&gt;&gt; c = Counter('gallahad')                 # a new counter from an iterable
&gt;&gt;&gt; c = Counter({'red': 4, 'blue': 2})      # a new counter from a mapping
&gt;&gt;&gt; c = Counter(cats=4, dogs=8)             # a new counter from keyword args</doctest_block>
                    <paragraph>Counter objects have a dictionary interface except that they return a zero
                        count for missing items instead of raising a KeyError:</paragraph>
                    <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; c = Counter(['eggs', 'ham'])
&gt;&gt;&gt; c['bacon']                              # count of a missing element is zero
0</doctest_block>
                    <paragraph>Setting a count to zero does not remove an element from a counter.
                        Use del to remove it entirely:</paragraph>
                    <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; c['sausage'] = 0                        # counter entry with a zero count
&gt;&gt;&gt; del c['sausage']                        # del actually removes the entry</doctest_block>
                    <versionmodified type="versionadded" version="3.1"><paragraph translatable="False">New in version 3.1.</paragraph></versionmodified>
                    <versionmodified type="versionchanged" version="3.7"><paragraph translatable="False">Changed in version 3.7: As a dict subclass, Counter
                            inherited the capability to remember insertion order.  Math operations
                            on <emphasis>Counter</emphasis> objects also preserve order.  Results are ordered
                            according to when an element is first encountered in the left operand
                            and then by the order encountered in the right operand.</paragraph></versionmodified>
                    <paragraph>Counter objects support additional methods beyond those available for all
                        dictionaries:</paragraph>
                    <index entries="['single',\ 'elements()\ (collections.Counter\ method)',\ 'collections.Counter.elements',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="Counter" classes="sig sig-object py sig sig-object" fullname="Counter.elements" ids="collections.Counter.elements" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">elements</desc_name><desc_parameterlist xml:space="preserve"></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Return an iterator over elements repeating each as many times as its
                                count.  Elements are returned in the order first encountered. If an
                                element’s count is less than one, elements() will ignore it.</paragraph>
                            <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; sorted(c.elements())
['a', 'a', 'a', 'a', 'b', 'b']</doctest_block>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'most_common()\ (collections.Counter\ method)',\ 'collections.Counter.most_common',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="Counter" classes="sig sig-object py sig sig-object" fullname="Counter.most_common" ids="collections.Counter.most_common" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">most_common</desc_name><desc_parameterlist xml:space="preserve"><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">n</desc_sig_name></desc_parameter></desc_optional></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Return a list of the <emphasis>n</emphasis> most common elements and their counts from the
                                most common to the least.  If <emphasis>n</emphasis> is omitted or None,
                                most_common() returns <emphasis>all</emphasis> elements in the counter.
                                Elements with equal counts are ordered in the order first encountered:</paragraph>
                            <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]</doctest_block>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'subtract()\ (collections.Counter\ method)',\ 'collections.Counter.subtract',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="Counter" classes="sig sig-object py sig sig-object" fullname="Counter.subtract" ids="collections.Counter.subtract" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">subtract</desc_name><desc_parameterlist xml:space="preserve"><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">iterable-or-mapping</desc_sig_name></desc_parameter></desc_optional></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Elements are subtracted from an <emphasis>iterable</emphasis> or from another <emphasis>mapping</emphasis>
                                (or counter).  Like dict.update() but subtracts counts instead
                                of replacing them.  Both inputs and outputs may be zero or negative.</paragraph>
                            <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; d = Counter(a=1, b=2, c=3, d=4)
&gt;&gt;&gt; c.subtract(d)
&gt;&gt;&gt; c
Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})</doctest_block>
                            <versionmodified type="versionadded" version="3.2"><paragraph translatable="False">New in version 3.2.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'total()\ (collections.Counter\ method)',\ 'collections.Counter.total',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="Counter" classes="sig sig-object py sig sig-object" fullname="Counter.total" ids="collections.Counter.total" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">total</desc_name><desc_parameterlist xml:space="preserve"></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Compute the sum of the counts.</paragraph>
                            <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; c = Counter(a=10, b=5, c=0)
&gt;&gt;&gt; c.total()
15</doctest_block>
                            <versionmodified type="versionadded" version="3.10"><paragraph translatable="False">New in version 3.10.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                    <paragraph>The usual dictionary methods are available for Counter objects
                        except for two which work differently for counters.</paragraph>
                    <index entries="['single',\ 'fromkeys()\ (collections.Counter\ method)',\ 'collections.Counter.fromkeys',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="Counter" classes="sig sig-object py sig sig-object" fullname="Counter.fromkeys" ids="collections.Counter.fromkeys" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">fromkeys</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">iterable</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>This class method is not implemented for Counter objects.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'update()\ (collections.Counter\ method)',\ 'collections.Counter.update',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="Counter" classes="sig sig-object py sig sig-object" fullname="Counter.update" ids="collections.Counter.update" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">update</desc_name><desc_parameterlist xml:space="preserve"><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">iterable-or-mapping</desc_sig_name></desc_parameter></desc_optional></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Elements are counted from an <emphasis>iterable</emphasis> or added-in from another
                                <emphasis>mapping</emphasis> (or counter).  Like dict.update() but adds counts
                                instead of replacing them.  Also, the <emphasis>iterable</emphasis> is expected to be a
                                sequence of elements, not a sequence of (key, value) pairs.</paragraph>
                        </desc_content>
                    </desc>
                </desc_content>
            </desc>
            <paragraph>Counters support rich comparison operators for equality, subset, and
                superset relationships: ==, !=, &lt;, &lt;=, &gt;, &gt;=.
                All of those tests treat missing elements as having zero counts so that
                Counter(a=1) == Counter(a=1, b=0) returns true.</paragraph>
            <versionmodified type="versionadded" version="3.10"><paragraph translatable="False">New in version 3.10: Rich comparison operations were added.</paragraph></versionmodified>
            <versionmodified type="versionchanged" version="3.10"><paragraph translatable="False">Changed in version 3.10: In equality tests, missing elements are treated as having zero counts.
                    Formerly, Counter(a=3) and Counter(a=3, b=0) were considered
                    distinct.</paragraph></versionmodified>
            <paragraph>Common patterns for working with Counter objects:</paragraph>
            <paragraph>c.total()                       # total of all counts
c.clear()                       # reset all counts
list(c)                         # list unique elements
set(c)                          # convert to a set
dict(c)                         # convert to a regular dictionary
c.items()                       # convert to a list of (elem, cnt) pairs
Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairs
c.most_common()[:-n-1:-1]       # n least common elements
+c                              # remove zero and negative counts</paragraph>
            <paragraph>Several mathematical operations are provided for combining Counter
                objects to produce multisets (counters that have counts greater than zero).
                Addition and subtraction combine counters by adding or subtracting the counts
                of corresponding elements.  Intersection and union return the minimum and
                maximum of corresponding counts.  Equality and inclusion compare
                corresponding counts.  Each operation can accept inputs with signed
                counts, but the output will exclude results with counts of zero or less.</paragraph>
            <paragraph>&gt;&gt;&gt; c = Counter(a=3, b=1)
&gt;&gt;&gt; d = Counter(a=1, b=2)
&gt;&gt;&gt; c + d                       # add two counters together:  c[x] + d[x]
Counter({'a': 4, 'b': 3})
&gt;&gt;&gt; c - d                       # subtract (keeping only positive counts)
Counter({'a': 2})
&gt;&gt;&gt; c &amp; d                       # intersection:  min(c[x], d[x])
Counter({'a': 1, 'b': 1})
&gt;&gt;&gt; c | d                       # union:  max(c[x], d[x])
Counter({'a': 3, 'b': 2})
&gt;&gt;&gt; c == d                      # equality:  c[x] == d[x]
False
&gt;&gt;&gt; c &lt;= d                      # inclusion:  c[x] &lt;= d[x]
False</paragraph>
            <paragraph>Unary addition and subtraction are shortcuts for adding an empty counter
                or subtracting from an empty counter.</paragraph>
            <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; c = Counter(a=2, b=-4)
&gt;&gt;&gt; +c
Counter({'a': 2})
&gt;&gt;&gt; -c
Counter({'b': 4})</doctest_block>
            <versionmodified type="versionadded" version="3.3"><paragraph translatable="False">New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations.</paragraph></versionmodified>
            <note>
                <paragraph>Counters were primarily designed to work with positive integers to represent
                    running counts; however, care was taken to not unnecessarily preclude use
                    cases needing other types or negative values.  To help with those use cases,
                    this section documents the minimum range and type restrictions.</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>The Counter class itself is a dictionary subclass with no
                            restrictions on its keys and values.  The values are intended to be numbers
                            representing counts, but you <emphasis>could</emphasis> store anything in the value field.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The most_common() method requires only that the values be orderable.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For in-place operations such as c[key] += 1, the value type need only
                            support addition and subtraction.  So fractions, floats, and decimals would
                            work and negative values are supported.  The same is also true for
                            update() and subtract() which allow negative and zero values
                            for both inputs and outputs.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The multiset methods are designed only for use cases with positive values.
                            The inputs may be negative or zero, but only outputs with positive values
                            are created.  There are no type restrictions, but the value type needs to
                            support addition, subtraction, and comparison.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The elements() method requires integer counts.  It ignores zero and
                            negative counts.</paragraph>
                    </list_item>
                </bullet_list>
            </note>
            <seealso>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Bag class<target ids="bag-class" names="bag\ class" refuri="https://www.gnu.org/software/smalltalk/manual-base/html_node/Bag.html"></target>
                            in Smalltalk.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Wikipedia entry for Multisets<target ids="multisets" names="multisets" refuri="https://en.wikipedia.org/wiki/Multiset"></target>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>C++ multisets<target ids="c-multisets" names="c++\ multisets" refuri="http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/Catalog0380__set-multiset.htm"></target>
                            tutorial with examples.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For mathematical operations on multisets and their use cases, see
                            <emphasis>Knuth, Donald. The Art of Computer Programming Volume II,
                                Section 4.6.3, Exercise 19</emphasis>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>To enumerate all distinct multisets of a given size over a given set of
                            elements, see itertools.combinations_with_replacement():</paragraph>
                        <paragraph>map(Counter, combinations_with_replacement('ABC', 2)) # --&gt; AA AB AC BB BC CC</paragraph>
                    </list_item>
                </bullet_list>
            </seealso>
        </section>
        <section ids="deque-objects" names="deque\ objects">
            <title>deque objects</title>
            <index entries="['single',\ 'deque\ (class\ in\ collections)',\ 'collections.deque',\ '',\ None]"></index>
            <desc classes="py class" desctype="class" domain="py" noindex="False" objtype="class">
                <desc_signature class="" classes="sig sig-object py sig sig-object" fullname="deque" ids="collections.deque" module="collections"><desc_annotation xml:space="preserve">class<desc_sig_space classes="w w">  </desc_sig_space></desc_annotation><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">collections.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">deque</desc_name><desc_parameterlist xml:space="preserve"><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">iterable</desc_sig_name></desc_parameter><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">maxlen</desc_sig_name></desc_parameter></desc_optional></desc_optional></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Returns a new deque object initialized left-to-right (using append()) with
                        data from <emphasis>iterable</emphasis>.  If <emphasis>iterable</emphasis> is not specified, the new deque is empty.</paragraph>
                    <paragraph>Deques are a generalization of stacks and queues (the name is pronounced “deck”
                        and is short for “double-ended queue”).  Deques support thread-safe, memory
                        efficient appends and pops from either side of the deque with approximately the
                        same O(1) performance in either direction.</paragraph>
                    <paragraph>Though list objects support similar operations, they are optimized for
                        fast fixed-length operations and incur O(n) memory movement costs for
                        pop(0) and insert(0, v) operations which change both the size and
                        position of the underlying data representation.</paragraph>
                    <paragraph>If <emphasis>maxlen</emphasis> is not specified or is None, deques may grow to an
                        arbitrary length.  Otherwise, the deque is bounded to the specified maximum
                        length.  Once a bounded length deque is full, when new items are added, a
                        corresponding number of items are discarded from the opposite end.  Bounded
                        length deques provide functionality similar to the tail filter in
                        Unix. They are also useful for tracking transactions and other pools of data
                        where only the most recent activity is of interest.</paragraph>
                    <paragraph>Deque objects support the following methods:</paragraph>
                    <index entries="['single',\ 'append()\ (collections.deque\ method)',\ 'collections.deque.append',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.append" ids="collections.deque.append" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">append</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">x</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Add <emphasis>x</emphasis> to the right side of the deque.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'appendleft()\ (collections.deque\ method)',\ 'collections.deque.appendleft',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.appendleft" ids="collections.deque.appendleft" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">appendleft</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">x</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Add <emphasis>x</emphasis> to the left side of the deque.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'clear()\ (collections.deque\ method)',\ 'collections.deque.clear',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.clear" ids="collections.deque.clear" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">clear</desc_name><desc_parameterlist xml:space="preserve"></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Remove all elements from the deque leaving it with length 0.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'copy()\ (collections.deque\ method)',\ 'collections.deque.copy',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.copy" ids="collections.deque.copy" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">copy</desc_name><desc_parameterlist xml:space="preserve"></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Create a shallow copy of the deque.</paragraph>
                            <versionmodified type="versionadded" version="3.5"><paragraph translatable="False">New in version 3.5.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'count()\ (collections.deque\ method)',\ 'collections.deque.count',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.count" ids="collections.deque.count" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">count</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">x</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Count the number of deque elements equal to <emphasis>x</emphasis>.</paragraph>
                            <versionmodified type="versionadded" version="3.2"><paragraph translatable="False">New in version 3.2.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'extend()\ (collections.deque\ method)',\ 'collections.deque.extend',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.extend" ids="collections.deque.extend" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">extend</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">iterable</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Extend the right side of the deque by appending elements from the iterable
                                argument.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'extendleft()\ (collections.deque\ method)',\ 'collections.deque.extendleft',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.extendleft" ids="collections.deque.extendleft" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">extendleft</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">iterable</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Extend the left side of the deque by appending elements from <emphasis>iterable</emphasis>.
                                Note, the series of left appends results in reversing the order of
                                elements in the iterable argument.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'index()\ (collections.deque\ method)',\ 'collections.deque.index',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.index" ids="collections.deque.index" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">index</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">x</desc_sig_name></desc_parameter><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">start</desc_sig_name></desc_parameter><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">stop</desc_sig_name></desc_parameter></desc_optional></desc_optional></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Return the position of <emphasis>x</emphasis> in the deque (at or after index <emphasis>start</emphasis>
                                and before index <emphasis>stop</emphasis>).  Returns the first match or raises
                                ValueError if not found.</paragraph>
                            <versionmodified type="versionadded" version="3.5"><paragraph translatable="False">New in version 3.5.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'insert()\ (collections.deque\ method)',\ 'collections.deque.insert',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.insert" ids="collections.deque.insert" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">insert</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">i</desc_sig_name></desc_parameter><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">x</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Insert <emphasis>x</emphasis> into the deque at position <emphasis>i</emphasis>.</paragraph>
                            <paragraph>If the insertion would cause a bounded deque to grow beyond <emphasis>maxlen</emphasis>,
                                an IndexError is raised.</paragraph>
                            <versionmodified type="versionadded" version="3.5"><paragraph translatable="False">New in version 3.5.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'pop()\ (collections.deque\ method)',\ 'collections.deque.pop',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.pop" ids="collections.deque.pop" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">pop</desc_name><desc_parameterlist xml:space="preserve"></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Remove and return an element from the right side of the deque. If no
                                elements are present, raises an IndexError.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'popleft()\ (collections.deque\ method)',\ 'collections.deque.popleft',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.popleft" ids="collections.deque.popleft" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">popleft</desc_name><desc_parameterlist xml:space="preserve"></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Remove and return an element from the left side of the deque. If no
                                elements are present, raises an IndexError.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'remove()\ (collections.deque\ method)',\ 'collections.deque.remove',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.remove" ids="collections.deque.remove" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">remove</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">value</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Remove the first occurrence of <emphasis>value</emphasis>.  If not found, raises a
                                ValueError.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'reverse()\ (collections.deque\ method)',\ 'collections.deque.reverse',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.reverse" ids="collections.deque.reverse" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">reverse</desc_name><desc_parameterlist xml:space="preserve"></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Reverse the elements of the deque in-place and then return None.</paragraph>
                            <versionmodified type="versionadded" version="3.2"><paragraph translatable="False">New in version 3.2.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'rotate()\ (collections.deque\ method)',\ 'collections.deque.rotate',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.rotate" ids="collections.deque.rotate" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">rotate</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">n</desc_sig_name><desc_sig_operator classes="o o">=</desc_sig_operator>1</desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Rotate the deque <emphasis>n</emphasis> steps to the right.  If <emphasis>n</emphasis> is negative, rotate
                                to the left.</paragraph>
                            <paragraph>When the deque is not empty, rotating one step to the right is equivalent
                                to d.appendleft(d.pop()), and rotating one step to the left is
                                equivalent to d.append(d.popleft()).</paragraph>
                        </desc_content>
                    </desc>
                    <paragraph>Deque objects also provide one read-only attribute:</paragraph>
                    <index entries="['single',\ 'maxlen\ (collections.deque\ attribute)',\ 'collections.deque.maxlen',\ '',\ None]"></index>
                    <desc classes="py attribute" desctype="attribute" domain="py" noindex="False" objtype="attribute">
                        <desc_signature class="deque" classes="sig sig-object py sig sig-object" fullname="deque.maxlen" ids="collections.deque.maxlen" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">maxlen</desc_name></desc_signature>
                        <desc_content>
                            <paragraph>Maximum size of a deque or None if unbounded.</paragraph>
                            <versionmodified type="versionadded" version="3.1"><paragraph translatable="False">New in version 3.1.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                </desc_content>
            </desc>
            <paragraph>In addition to the above, deques support iteration, pickling, len(d),
                reversed(d), copy.copy(d), copy.deepcopy(d), membership testing with
                the in operator, and subscript references such as d[0] to access
                the first element.  Indexed access is O(1) at both ends but slows to O(n) in
                the middle.  For fast random access, use lists instead.</paragraph>
            <paragraph>Starting in version 3.5, deques support __add__(), __mul__(),
                and __imul__().</paragraph>
            <paragraph>Example:</paragraph>
            <paragraph>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; d = deque('ghi')                 # make a new deque with three items
&gt;&gt;&gt; for elem in d:                   # iterate over the deque's elements
...     print(elem.upper())
G
H
I

&gt;&gt;&gt; d.append('j')                    # add a new entry to the right side
&gt;&gt;&gt; d.appendleft('f')                # add a new entry to the left side
&gt;&gt;&gt; d                                # show the representation of the deque
deque(['f', 'g', 'h', 'i', 'j'])

&gt;&gt;&gt; d.pop()                          # return and remove the rightmost item
'j'
&gt;&gt;&gt; d.popleft()                      # return and remove the leftmost item
'f'
&gt;&gt;&gt; list(d)                          # list the contents of the deque
['g', 'h', 'i']
&gt;&gt;&gt; d[0]                             # peek at leftmost item
'g'
&gt;&gt;&gt; d[-1]                            # peek at rightmost item
'i'

&gt;&gt;&gt; list(reversed(d))                # list the contents of a deque in reverse
['i', 'h', 'g']
&gt;&gt;&gt; 'h' in d                         # search the deque
True
&gt;&gt;&gt; d.extend('jkl')                  # add multiple elements at once
&gt;&gt;&gt; d
deque(['g', 'h', 'i', 'j', 'k', 'l'])
&gt;&gt;&gt; d.rotate(1)                      # right rotation
&gt;&gt;&gt; d
deque(['l', 'g', 'h', 'i', 'j', 'k'])
&gt;&gt;&gt; d.rotate(-1)                     # left rotation
&gt;&gt;&gt; d
deque(['g', 'h', 'i', 'j', 'k', 'l'])

&gt;&gt;&gt; deque(reversed(d))               # make a new deque in reverse order
deque(['l', 'k', 'j', 'i', 'h', 'g'])
&gt;&gt;&gt; d.clear()                        # empty the deque
&gt;&gt;&gt; d.pop()                          # cannot pop from an empty deque
Traceback (most recent call last):
    File "&lt;pyshell#6&gt;", line 1, in -toplevel-
        d.pop()
IndexError: pop from an empty deque

&gt;&gt;&gt; d.extendleft('abc')              # extendleft() reverses the input order
&gt;&gt;&gt; d
deque(['c', 'b', 'a'])</paragraph>
            <section ids="deque-recipes" names="deque\ recipes">
                <title>deque Recipes</title>
                <paragraph>This section shows various approaches to working with deques.</paragraph>
                <paragraph>Bounded length deques provide functionality similar to the tail filter
                    in Unix:</paragraph>
                <paragraph>def tail(filename, n=10):
    'Return the last n lines of a file'
    with open(filename) as f:
        return deque(f, n)</paragraph>
                <paragraph>Another approach to using deques is to maintain a sequence of recently
                    added elements by appending to the right and popping to the left:</paragraph>
                <paragraph>def moving_average(iterable, n=3):
    # moving_average([40, 30, 50, 46, 39, 44]) --&gt; 40.0 42.0 45.0 43.0
    # https://en.wikipedia.org/wiki/Moving_average
    it = iter(iterable)
    d = deque(itertools.islice(it, n-1))
    d.appendleft(0)
    s = sum(d)
    for elem in it:
        s += elem - d.popleft()
        d.append(elem)
        yield s / n</paragraph>
                <paragraph>A round-robin scheduler<target ids="round-robin-scheduler" names="round-robin\ scheduler" refuri="https://en.wikipedia.org/wiki/Round-robin_scheduling"></target> can be implemented with
                    input iterators stored in a deque.  Values are yielded from the active
                    iterator in position zero.  If that iterator is exhausted, it can be removed
                    with popleft(); otherwise, it can be cycled back to the end with
                    the rotate() method:</paragraph>
                <paragraph>def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    iterators = deque(map(iter, iterables))
    while iterators:
        try:
            while True:
                yield next(iterators[0])
                iterators.rotate(-1)
        except StopIteration:
            # Remove an exhausted iterator.
            iterators.popleft()</paragraph>
                <paragraph>The rotate() method provides a way to implement deque slicing and
                    deletion.  For example, a pure Python implementation of del d[n] relies on
                    the rotate() method to position elements to be popped:</paragraph>
                <paragraph>def delete_nth(d, n):
    d.rotate(-n)
    d.popleft()
    d.rotate(n)</paragraph>
                <paragraph>To implement deque slicing, use a similar approach applying
                    rotate() to bring a target element to the left side of the deque. Remove
                    old entries with popleft(), add new entries with extend(), and then
                    reverse the rotation.
                    With minor variations on that approach, it is easy to implement Forth style
                    stack manipulations such as dup, drop, swap, over, pick,
                    rot, and roll.</paragraph>
            </section>
        </section>
        <section ids="defaultdict-objects" names="defaultdict\ objects">
            <title>defaultdict objects</title>
            <index entries="['single',\ 'defaultdict\ (class\ in\ collections)',\ 'collections.defaultdict',\ '',\ None]"></index>
            <desc classes="py class" desctype="class" domain="py" noindex="False" objtype="class">
                <desc_signature class="" classes="sig sig-object py sig sig-object" fullname="defaultdict" ids="collections.defaultdict" module="collections"><desc_annotation xml:space="preserve">class<desc_sig_space classes="w w">  </desc_sig_space></desc_annotation><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">collections.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">defaultdict</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">default_factory=None</desc_sig_name></desc_parameter><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">/</desc_sig_name></desc_parameter><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">...</desc_sig_name></desc_parameter></desc_optional></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Return a new dictionary-like object.  defaultdict is a subclass of the
                        built-in dict class.  It overrides one method and adds one writable
                        instance variable.  The remaining functionality is the same as for the
                        dict class and is not documented here.</paragraph>
                    <paragraph>The first argument provides the initial value for the default_factory
                        attribute; it defaults to None. All remaining arguments are treated the same
                        as if they were passed to the dict constructor, including keyword
                        arguments.</paragraph>
                    <paragraph>defaultdict objects support the following method in addition to the
                        standard dict operations:</paragraph>
                    <index entries="['single',\ '__missing__()\ (collections.defaultdict\ method)',\ 'collections.defaultdict.__missing__',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="defaultdict" classes="sig sig-object py sig sig-object" fullname="defaultdict.__missing__" ids="collections.defaultdict.__missing__" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">__missing__</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">key</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>If the default_factory attribute is None, this raises a
                                KeyError exception with the <emphasis>key</emphasis> as argument.</paragraph>
                            <paragraph>If default_factory is not None, it is called without arguments
                                to provide a default value for the given <emphasis>key</emphasis>, this value is inserted in
                                the dictionary for the <emphasis>key</emphasis>, and returned.</paragraph>
                            <paragraph>If calling default_factory raises an exception this exception is
                                propagated unchanged.</paragraph>
                            <paragraph>This method is called by the __getitem__() method of the
                                dict class when the requested key is not found; whatever it
                                returns or raises is then returned or raised by __getitem__().</paragraph>
                            <paragraph>Note that __missing__() is <emphasis>not</emphasis> called for any operations besides
                                __getitem__(). This means that get() will, like normal
                                dictionaries, return None as a default rather than using
                                default_factory.</paragraph>
                        </desc_content>
                    </desc>
                    <paragraph>defaultdict objects support the following instance variable:</paragraph>
                    <index entries="['single',\ 'default_factory\ (collections.defaultdict\ attribute)',\ 'collections.defaultdict.default_factory',\ '',\ None]"></index>
                    <desc classes="py attribute" desctype="attribute" domain="py" noindex="False" objtype="attribute">
                        <desc_signature class="defaultdict" classes="sig sig-object py sig sig-object" fullname="defaultdict.default_factory" ids="collections.defaultdict.default_factory" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">default_factory</desc_name></desc_signature>
                        <desc_content>
                            <paragraph>This attribute is used by the __missing__() method; it is
                                initialized from the first argument to the constructor, if present, or to
                                None, if absent.</paragraph>
                        </desc_content>
                    </desc>
                    <versionmodified type="versionchanged" version="3.9"><paragraph translatable="False">Changed in version 3.9: Added merge (|) and update (|=) operators, specified in
                            <index entries="['single',\ 'Python\ Enhancement\ Proposals;\ PEP\ 584',\ 'index-1',\ '',\ None]"></index><target ids="index-1"></target><strong>PEP 584</strong>.</paragraph></versionmodified>
                </desc_content>
            </desc>
            <section ids="defaultdict-examples" names="defaultdict\ examples">
                <title>defaultdict Examples</title>
                <paragraph>Using list as the default_factory, it is easy to group a
                    sequence of key-value pairs into a dictionary of lists:</paragraph>
                <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; sorted(d.items())
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]</doctest_block>
                <paragraph>When each key is encountered for the first time, it is not already in the
                    mapping; so an entry is automatically created using the default_factory
                    function which returns an empty list.  The list.append()
                    operation then attaches the value to the new list.  When keys are encountered
                    again, the look-up proceeds normally (returning the list for that key) and the
                    list.append() operation adds another value to the list. This technique is
                    simpler and faster than an equivalent technique using dict.setdefault():</paragraph>
                <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; d = {}
&gt;&gt;&gt; for k, v in s:
...     d.setdefault(k, []).append(v)
...
&gt;&gt;&gt; sorted(d.items())
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]</doctest_block>
                <paragraph>Setting the default_factory to int makes the
                    defaultdict useful for counting (like a bag or multiset in other
                    languages):</paragraph>
                <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; s = 'mississippi'
&gt;&gt;&gt; d = defaultdict(int)
&gt;&gt;&gt; for k in s:
...     d[k] += 1
...
&gt;&gt;&gt; sorted(d.items())
[('i', 4), ('m', 1), ('p', 2), ('s', 4)]</doctest_block>
                <paragraph>When a letter is first encountered, it is missing from the mapping, so the
                    default_factory function calls int() to supply a default count of
                    zero.  The increment operation then builds up the count for each letter.</paragraph>
                <paragraph>The function int() which always returns zero is just a special case of
                    constant functions.  A faster and more flexible way to create constant functions
                    is to use a lambda function which can supply any constant value (not just
                    zero):</paragraph>
                <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; def constant_factory(value):
...     return lambda: value
...
&gt;&gt;&gt; d = defaultdict(constant_factory('&lt;missing&gt;'))
&gt;&gt;&gt; d.update(name='John', action='ran')
&gt;&gt;&gt; '%(name)s %(action)s to %(object)s' % d
'John ran to &lt;missing&gt;'</doctest_block>
                <paragraph>Setting the default_factory to set makes the
                    defaultdict useful for building a dictionary of sets:</paragraph>
                <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; s = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)]
&gt;&gt;&gt; d = defaultdict(set)
&gt;&gt;&gt; for k, v in s:
...     d[k].add(v)
...
&gt;&gt;&gt; sorted(d.items())
[('blue', {2, 4}), ('red', {1, 3})]</doctest_block>
            </section>
        </section>
        <section ids="namedtuple-factory-function-for-tuples-with-named-fields" names="namedtuple()\ factory\ function\ for\ tuples\ with\ named\ fields">
            <title>namedtuple() Factory Function for Tuples with Named Fields</title>
            <paragraph>Named tuples assign meaning to each position in a tuple and allow for more readable,
                self-documenting code.  They can be used wherever regular tuples are used, and
                they add the ability to access fields by name instead of position index.</paragraph>
            <index entries="['single',\ 'namedtuple()\ (in\ module\ collections)',\ 'collections.namedtuple',\ '',\ None]"></index>
            <desc classes="py function" desctype="function" domain="py" noindex="False" objtype="function">
                <desc_signature class="" classes="sig sig-object py sig sig-object" fullname="namedtuple" ids="collections.namedtuple" module="collections"><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">collections.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">namedtuple</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">typename</desc_sig_name></desc_parameter><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">field_names</desc_sig_name></desc_parameter><desc_parameter xml:space="preserve"><desc_sig_operator classes="o o">*</desc_sig_operator></desc_parameter><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">rename</desc_sig_name><desc_sig_operator classes="o o">=</desc_sig_operator>False</desc_parameter><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">defaults</desc_sig_name><desc_sig_operator classes="o o">=</desc_sig_operator>None</desc_parameter><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">module</desc_sig_name><desc_sig_operator classes="o o">=</desc_sig_operator>None</desc_parameter></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Returns a new tuple subclass named <emphasis>typename</emphasis>.  The new subclass is used to
                        create tuple-like objects that have fields accessible by attribute lookup as
                        well as being indexable and iterable.  Instances of the subclass also have a
                        helpful docstring (with typename and field_names) and a helpful __repr__()
                        method which lists the tuple contents in a name=value format.</paragraph>
                    <paragraph>The <emphasis>field_names</emphasis> are a sequence of strings such as ['x', 'y'].
                        Alternatively, <emphasis>field_names</emphasis> can be a single string with each fieldname
                        separated by whitespace and/or commas, for example 'x y' or 'x, y'.</paragraph>
                    <paragraph>Any valid Python identifier may be used for a fieldname except for names
                        starting with an underscore.  Valid identifiers consist of letters, digits,
                        and underscores but do not start with a digit or underscore and cannot be
                        a keyword such as <emphasis>class</emphasis>, <emphasis>for</emphasis>, <emphasis>return</emphasis>, <emphasis>global</emphasis>, <emphasis>pass</emphasis>,
                        or <emphasis>raise</emphasis>.</paragraph>
                    <paragraph>If <emphasis>rename</emphasis> is true, invalid fieldnames are automatically replaced
                        with positional names.  For example, ['abc', 'def', 'ghi', 'abc'] is
                        converted to ['abc', '_1', 'ghi', '_3'], eliminating the keyword
                        def and the duplicate fieldname abc.</paragraph>
                    <paragraph><emphasis>defaults</emphasis> can be None or an iterable of default values.
                        Since fields with a default value must come after any fields without a
                        default, the <emphasis>defaults</emphasis> are applied to the rightmost parameters.  For
                        example, if the fieldnames are ['x', 'y', 'z'] and the defaults are
                        (1, 2), then x will be a required argument, y will default to
                        1, and z will default to 2.</paragraph>
                    <paragraph>If <emphasis>module</emphasis> is defined, the __module__ attribute of the named tuple is
                        set to that value.</paragraph>
                    <paragraph>Named tuple instances do not have per-instance dictionaries, so they are
                        lightweight and require no more memory than regular tuples.</paragraph>
                    <paragraph>To support pickling, the named tuple class should be assigned to a variable
                        that matches <emphasis>typename</emphasis>.</paragraph>
                    <versionmodified type="versionchanged" version="3.1"><paragraph translatable="False">Changed in version 3.1: Added support for <emphasis>rename</emphasis>.</paragraph></versionmodified>
                    <versionmodified type="versionchanged" version="3.6"><paragraph translatable="False">Changed in version 3.6: The <emphasis>verbose</emphasis> and <emphasis>rename</emphasis> parameters became
                            keyword-only arguments.</paragraph></versionmodified>
                    <versionmodified type="versionchanged" version="3.6"><paragraph translatable="False">Changed in version 3.6: Added the <emphasis>module</emphasis> parameter.</paragraph></versionmodified>
                    <versionmodified type="versionchanged" version="3.7"><paragraph translatable="False">Changed in version 3.7: Removed the <emphasis>verbose</emphasis> parameter and the _source attribute.</paragraph></versionmodified>
                    <versionmodified type="versionchanged" version="3.7"><paragraph translatable="False">Changed in version 3.7: Added the <emphasis>defaults</emphasis> parameter and the _field_defaults
                            attribute.</paragraph></versionmodified>
                </desc_content>
            </desc>
            <paragraph>&gt;&gt;&gt; # Basic example
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])
&gt;&gt;&gt; p = Point(11, y=22)     # instantiate with positional or keyword arguments
&gt;&gt;&gt; p[0] + p[1]             # indexable like the plain tuple (11, 22)
33
&gt;&gt;&gt; x, y = p                # unpack like a regular tuple
&gt;&gt;&gt; x, y
(11, 22)
&gt;&gt;&gt; p.x + p.y               # fields also accessible by name
33
&gt;&gt;&gt; p                       # readable __repr__ with a name=value style
Point(x=11, y=22)</paragraph>
            <paragraph>Named tuples are especially useful for assigning field names to result tuples returned
                by the csv or sqlite3 modules:</paragraph>
            <paragraph>EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, paygrade')

import csv
for emp in map(EmployeeRecord._make, csv.reader(open("employees.csv", "rb"))):
    print(emp.name, emp.title)

import sqlite3
conn = sqlite3.connect('/companydata')
cursor = conn.cursor()
cursor.execute('SELECT name, age, title, department, paygrade FROM employees')
for emp in map(EmployeeRecord._make, cursor.fetchall()):
    print(emp.name, emp.title)</paragraph>
            <paragraph>In addition to the methods inherited from tuples, named tuples support
                three additional methods and two attributes.  To prevent conflicts with
                field names, the method and attribute names start with an underscore.</paragraph>
            <index entries="['single',\ '_make()\ (collections.somenamedtuple\ class\ method)',\ 'collections.somenamedtuple._make',\ '',\ None]"></index>
            <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                <desc_signature class="somenamedtuple" classes="sig sig-object py sig sig-object" fullname="somenamedtuple._make" ids="collections.somenamedtuple._make" module="collections"><desc_annotation xml:space="preserve">classmethod<desc_sig_space classes="w w">  </desc_sig_space></desc_annotation><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">somenamedtuple.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">_make</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">iterable</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Class method that makes a new instance from an existing sequence or iterable.</paragraph>
                    <paragraph>&gt;&gt;&gt; t = [11, 22]
&gt;&gt;&gt; Point._make(t)
Point(x=11, y=22)</paragraph>
                </desc_content>
            </desc>
            <index entries="['single',\ '_asdict()\ (collections.somenamedtuple\ method)',\ 'collections.somenamedtuple._asdict',\ '',\ None]"></index>
            <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                <desc_signature class="somenamedtuple" classes="sig sig-object py sig sig-object" fullname="somenamedtuple._asdict" ids="collections.somenamedtuple._asdict" module="collections"><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">somenamedtuple.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">_asdict</desc_name><desc_parameterlist xml:space="preserve"></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Return a new dict which maps field names to their corresponding
                        values:</paragraph>
                    <paragraph>&gt;&gt;&gt; p = Point(x=11, y=22)
&gt;&gt;&gt; p._asdict()
{'x': 11, 'y': 22}</paragraph>
                    <versionmodified type="versionchanged" version="3.1"><paragraph translatable="False">Changed in version 3.1: Returns an OrderedDict instead of a regular dict.</paragraph></versionmodified>
                    <versionmodified type="versionchanged" version="3.8"><paragraph translatable="False">Changed in version 3.8: Returns a regular dict instead of an OrderedDict.
                            As of Python 3.7, regular dicts are guaranteed to be ordered.  If the
                            extra features of OrderedDict are required, the suggested
                            remediation is to cast the result to the desired type:
                            OrderedDict(nt._asdict()).</paragraph></versionmodified>
                </desc_content>
            </desc>
            <index entries="['single',\ '_replace()\ (collections.somenamedtuple\ method)',\ 'collections.somenamedtuple._replace',\ '',\ None]"></index>
            <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                <desc_signature class="somenamedtuple" classes="sig sig-object py sig sig-object" fullname="somenamedtuple._replace" ids="collections.somenamedtuple._replace" module="collections"><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">somenamedtuple.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">_replace</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_operator classes="o o">**</desc_sig_operator><desc_sig_name classes="n n">kwargs</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Return a new instance of the named tuple replacing specified fields with new
                        values:</paragraph>
                    <paragraph>&gt;&gt;&gt; p = Point(x=11, y=22)
&gt;&gt;&gt; p._replace(x=33)
Point(x=33, y=22)

&gt;&gt;&gt; for partnum, record in inventory.items():
...     inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now())</paragraph>
                </desc_content>
            </desc>
            <index entries="['single',\ '_fields\ (collections.somenamedtuple\ attribute)',\ 'collections.somenamedtuple._fields',\ '',\ None]"></index>
            <desc classes="py attribute" desctype="attribute" domain="py" noindex="False" objtype="attribute">
                <desc_signature class="somenamedtuple" classes="sig sig-object py sig sig-object" fullname="somenamedtuple._fields" ids="collections.somenamedtuple._fields" module="collections"><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">somenamedtuple.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">_fields</desc_name></desc_signature>
                <desc_content>
                    <paragraph>Tuple of strings listing the field names.  Useful for introspection
                        and for creating new named tuple types from existing named tuples.</paragraph>
                    <paragraph>&gt;&gt;&gt; p._fields            # view the field names
('x', 'y')

&gt;&gt;&gt; Color = namedtuple('Color', 'red green blue')
&gt;&gt;&gt; Pixel = namedtuple('Pixel', Point._fields + Color._fields)
&gt;&gt;&gt; Pixel(11, 22, 128, 255, 0)
Pixel(x=11, y=22, red=128, green=255, blue=0)</paragraph>
                </desc_content>
            </desc>
            <index entries="['single',\ '_field_defaults\ (collections.somenamedtuple\ attribute)',\ 'collections.somenamedtuple._field_defaults',\ '',\ None]"></index>
            <desc classes="py attribute" desctype="attribute" domain="py" noindex="False" objtype="attribute">
                <desc_signature class="somenamedtuple" classes="sig sig-object py sig sig-object" fullname="somenamedtuple._field_defaults" ids="collections.somenamedtuple._field_defaults" module="collections"><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">somenamedtuple.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">_field_defaults</desc_name></desc_signature>
                <desc_content>
                    <paragraph>Dictionary mapping field names to default values.</paragraph>
                    <paragraph>&gt;&gt;&gt; Account = namedtuple('Account', ['type', 'balance'], defaults=[0])
&gt;&gt;&gt; Account._field_defaults
{'balance': 0}
&gt;&gt;&gt; Account('premium')
Account(type='premium', balance=0)</paragraph>
                </desc_content>
            </desc>
            <paragraph>To retrieve a field whose name is stored in a string, use the getattr()
                function:</paragraph>
            <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; getattr(p, 'x')
11</doctest_block>
            <paragraph>To convert a dictionary to a named tuple, use the double-star-operator
                (as described in Unpacking Argument Lists):</paragraph>
            <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; d = {'x': 11, 'y': 22}
&gt;&gt;&gt; Point(**d)
Point(x=11, y=22)</doctest_block>
            <paragraph>Since a named tuple is a regular Python class, it is easy to add or change
                functionality with a subclass.  Here is how to add a calculated field and
                a fixed-width print format:</paragraph>
            <paragraph>&gt;&gt;&gt; class Point(namedtuple('Point', ['x', 'y'])):
...     __slots__ = ()
...     @property
...     def hypot(self):
...         return (self.x ** 2 + self.y ** 2) ** 0.5
...     def __str__(self):
...         return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, self.hypot)

&gt;&gt;&gt; for p in Point(3, 4), Point(14, 5/7):
...     print(p)
Point: x= 3.000  y= 4.000  hypot= 5.000
Point: x=14.000  y= 0.714  hypot=14.018</paragraph>
            <paragraph>The subclass shown above sets __slots__ to an empty tuple.  This helps
                keep memory requirements low by preventing the creation of instance dictionaries.</paragraph>
            <paragraph>Subclassing is not useful for adding new, stored fields.  Instead, simply
                create a new named tuple type from the _fields attribute:</paragraph>
            <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; Point3D = namedtuple('Point3D', Point._fields + ('z',))</doctest_block>
            <paragraph>Docstrings can be customized by making direct assignments to the __doc__
                fields:</paragraph>
            <doctest_block classes="doctest" xml:space="preserve">&gt;&gt;&gt; Book = namedtuple('Book', ['id', 'title', 'authors'])
&gt;&gt;&gt; Book.__doc__ += ': Hardcover book in active collection'
&gt;&gt;&gt; Book.id.__doc__ = '13-digit ISBN'
&gt;&gt;&gt; Book.title.__doc__ = 'Title of first printing'
&gt;&gt;&gt; Book.authors.__doc__ = 'List of authors sorted by last name'</doctest_block>
            <versionmodified type="versionchanged" version="3.5"><paragraph translatable="False">Changed in version 3.5: Property docstrings became writeable.</paragraph></versionmodified>
            <seealso>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>See typing.NamedTuple for a way to add type hints for named
                            tuples.  It also provides an elegant notation using the class
                            keyword:</paragraph>
                        <paragraph>class Component(NamedTuple):
    part_number: int
    weight: float
    description: Optional[str] = None</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>See types.SimpleNamespace() for a mutable namespace based on an
                            underlying dictionary instead of a tuple.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The dataclasses module provides a decorator and functions for
                            automatically adding generated special methods to user-defined classes.</paragraph>
                    </list_item>
                </bullet_list>
            </seealso>
        </section>
        <section ids="ordereddict-objects" names="ordereddict\ objects">
            <title>OrderedDict objects</title>
            <paragraph>Ordered dictionaries are just like regular dictionaries but have some extra
                capabilities relating to ordering operations.  They have become less
                important now that the built-in dict class gained the ability
                to remember insertion order (this new behavior became guaranteed in
                Python 3.7).</paragraph>
            <paragraph>Some differences from dict still remain:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>The regular dict was designed to be very good at mapping
                        operations.  Tracking insertion order was secondary.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The OrderedDict was designed to be good at reordering operations.
                        Space efficiency, iteration speed, and the performance of update
                        operations were secondary.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The OrderedDict algorithm can handle frequent reordering operations
                        better than dict.  As shown in the recipes below, this makes it
                        suitable for implementing various kinds of LRU caches.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The equality operation for OrderedDict checks for matching order.</paragraph>
                    <paragraph>A regular dict can emulate the order sensitive equality test with
                        p == q and all(k1 == k2 for k1, k2 in zip(p, q)).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The popitem() method of OrderedDict has a different
                        signature.  It accepts an optional argument to specify which item is popped.</paragraph>
                    <paragraph>A regular dict can emulate OrderedDict’s od.popitem(last=True)
                        with d.popitem() which is guaranteed to pop the rightmost (last) item.</paragraph>
                    <paragraph>A regular dict can emulate OrderedDict’s od.popitem(last=False)
                        with (k := next(iter(d)), d.pop(k)) which will return and remove the
                        leftmost (first) item if it exists.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>OrderedDict has a move_to_end() method to efficiently
                        reposition an element to an endpoint.</paragraph>
                    <paragraph>A regular dict can emulate OrderedDict’s od.move_to_end(k,
last=True) with d[k] = d.pop(k) which will move the key and its
                        associated value to the rightmost (last) position.</paragraph>
                    <paragraph>A regular dict does not have an efficient equivalent for
                        OrderedDict’s od.move_to_end(k, last=False) which moves the key
                        and its associated value to the leftmost (first) position.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Until Python 3.8, dict lacked a __reversed__() method.</paragraph>
                </list_item>
            </bullet_list>
            <index entries="['single',\ 'OrderedDict\ (class\ in\ collections)',\ 'collections.OrderedDict',\ '',\ None]"></index>
            <desc classes="py class" desctype="class" domain="py" noindex="False" objtype="class">
                <desc_signature class="" classes="sig sig-object py sig sig-object" fullname="OrderedDict" ids="collections.OrderedDict" module="collections"><desc_annotation xml:space="preserve">class<desc_sig_space classes="w w">  </desc_sig_space></desc_annotation><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">collections.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">OrderedDict</desc_name><desc_parameterlist xml:space="preserve"><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">items</desc_sig_name></desc_parameter></desc_optional></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Return an instance of a dict subclass that has methods
                        specialized for rearranging dictionary order.</paragraph>
                    <versionmodified type="versionadded" version="3.1"><paragraph translatable="False">New in version 3.1.</paragraph></versionmodified>
                    <index entries="['single',\ 'popitem()\ (collections.OrderedDict\ method)',\ 'collections.OrderedDict.popitem',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="OrderedDict" classes="sig sig-object py sig sig-object" fullname="OrderedDict.popitem" ids="collections.OrderedDict.popitem" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">popitem</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">last</desc_sig_name><desc_sig_operator classes="o o">=</desc_sig_operator>True</desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>The popitem() method for ordered dictionaries returns and removes a
                                (key, value) pair.  The pairs are returned in
                                <abbreviation explanation="last-in, first-out">LIFO</abbreviation> order if <emphasis>last</emphasis> is true
                                or <abbreviation explanation="first-in, first-out">FIFO</abbreviation> order if false.</paragraph>
                        </desc_content>
                    </desc>
                    <index entries="['single',\ 'move_to_end()\ (collections.OrderedDict\ method)',\ 'collections.OrderedDict.move_to_end',\ '',\ None]"></index>
                    <desc classes="py method" desctype="method" domain="py" noindex="False" objtype="method">
                        <desc_signature class="OrderedDict" classes="sig sig-object py sig sig-object" fullname="OrderedDict.move_to_end" ids="collections.OrderedDict.move_to_end" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">move_to_end</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">key</desc_sig_name></desc_parameter><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">last</desc_sig_name><desc_sig_operator classes="o o">=</desc_sig_operator>True</desc_parameter></desc_parameterlist></desc_signature>
                        <desc_content>
                            <paragraph>Move an existing <emphasis>key</emphasis> to either end of an ordered dictionary.  The item
                                is moved to the right end if <emphasis>last</emphasis> is true (the default) or to the
                                beginning if <emphasis>last</emphasis> is false.  Raises KeyError if the <emphasis>key</emphasis> does
                                not exist:</paragraph>
                            <paragraph>&gt;&gt;&gt; d = OrderedDict.fromkeys('abcde')
&gt;&gt;&gt; d.move_to_end('b')
&gt;&gt;&gt; ''.join(d)
'acdeb'
&gt;&gt;&gt; d.move_to_end('b', last=False)
&gt;&gt;&gt; ''.join(d)
'bacde'</paragraph>
                            <versionmodified type="versionadded" version="3.2"><paragraph translatable="False">New in version 3.2.</paragraph></versionmodified>
                        </desc_content>
                    </desc>
                </desc_content>
            </desc>
            <paragraph>In addition to the usual mapping methods, ordered dictionaries also support
                reverse iteration using reversed().</paragraph>
            <paragraph>Equality tests between OrderedDict objects are order-sensitive
                and are implemented as list(od1.items())==list(od2.items()).
                Equality tests between OrderedDict objects and other
                Mapping objects are order-insensitive like regular
                dictionaries.  This allows OrderedDict objects to be substituted
                anywhere a regular dictionary is used.</paragraph>
            <versionmodified type="versionchanged" version="3.5"><paragraph translatable="False">Changed in version 3.5: The items, keys, and values views
                    of OrderedDict now support reverse iteration using reversed().</paragraph></versionmodified>
            <versionmodified type="versionchanged" version="3.6"><paragraph translatable="False">Changed in version 3.6: With the acceptance of <index entries="['single',\ 'Python\ Enhancement\ Proposals;\ PEP\ 468',\ 'index-2',\ '',\ None]"></index><target ids="index-2"></target><strong>PEP 468</strong>, order is retained for keyword arguments
                    passed to the OrderedDict constructor and its update()
                    method.</paragraph></versionmodified>
            <versionmodified type="versionchanged" version="3.9"><paragraph translatable="False">Changed in version 3.9: Added merge (|) and update (|=) operators, specified in <index entries="['single',\ 'Python\ Enhancement\ Proposals;\ PEP\ 584',\ 'index-3',\ '',\ None]"></index><target ids="index-3"></target><strong>PEP 584</strong>.</paragraph></versionmodified>
            <section ids="ordereddict-examples-and-recipes" names="ordereddict\ examples\ and\ recipes">
                <title>OrderedDict Examples and Recipes</title>
                <paragraph>It is straightforward to create an ordered dictionary variant
                    that remembers the order the keys were <emphasis>last</emphasis> inserted.
                    If a new entry overwrites an existing entry, the
                    original insertion position is changed and moved to the end:</paragraph>
                <paragraph>class LastUpdatedOrderedDict(OrderedDict):
    'Store items in the order the keys were last added'

    def __setitem__(self, key, value):
        super().__setitem__(key, value)
        self.move_to_end(key)</paragraph>
                <paragraph>An OrderedDict would also be useful for implementing
                    variants of functools.lru_cache():</paragraph>
                <paragraph>from collections import OrderedDict
from time import time

class TimeBoundedLRU:
    "LRU Cache that invalidates and refreshes old entries."

    def __init__(self, func, maxsize=128, maxage=30):
        self.cache = OrderedDict()      # { args : (timestamp, result)}
        self.func = func
        self.maxsize = maxsize
        self.maxage = maxage

    def __call__(self, *args):
        if args in self.cache:
            self.cache.move_to_end(args)
            timestamp, result = self.cache[args]
            if time() - timestamp &lt;= self.maxage:
                return result
        result = self.func(*args)
        self.cache[args] = time(), result
        if len(self.cache) &gt; self.maxsize:
            self.cache.popitem(0)
        return result</paragraph>
                <paragraph>class MultiHitLRUCache:
    """ LRU cache that defers caching a result until
        it has been requested multiple times.

        To avoid flushing the LRU cache with one-time requests,
        we don't cache until a request has been made more than once.

    """

    def __init__(self, func, maxsize=128, maxrequests=4096, cache_after=1):
        self.requests = OrderedDict()   # { uncached_key : request_count }
        self.cache = OrderedDict()      # { cached_key : function_result }
        self.func = func
        self.maxrequests = maxrequests  # max number of uncached requests
        self.maxsize = maxsize          # max number of stored return values
        self.cache_after = cache_after

    def __call__(self, *args):
        if args in self.cache:
            self.cache.move_to_end(args)
            return self.cache[args]
        result = self.func(*args)
        self.requests[args] = self.requests.get(args, 0) + 1
        if self.requests[args] &lt;= self.cache_after:
            self.requests.move_to_end(args)
            if len(self.requests) &gt; self.maxrequests:
                self.requests.popitem(0)
        else:
            self.requests.pop(args, None)
            self.cache[args] = result
            if len(self.cache) &gt; self.maxsize:
                self.cache.popitem(0)
        return result</paragraph>
                <comment groups="default" language="pycon3" options="{}" testnodetype="doctest" xml:space="preserve">&gt;&gt;&gt; def square(x):
...     return x * x
...
&gt;&gt;&gt; f = MultiHitLRUCache(square, maxsize=4, maxrequests=6)
&gt;&gt;&gt; list(map(f, range(10)))  # First requests, don't cache
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; f(4)  # Cache the second request
16
&gt;&gt;&gt; f(6)  # Cache the second request
36
&gt;&gt;&gt; f(2)  # The first request aged out, so don't cache
4
&gt;&gt;&gt; f(6)  # Cache hit
36
&gt;&gt;&gt; f(4)  # Cache hit and move to front
16
&gt;&gt;&gt; list(f.cache.values())
[36, 16]
&gt;&gt;&gt; set(f.requests).isdisjoint(f.cache)
True
&gt;&gt;&gt; list(map(f, [9, 8, 7]))   # Cache these second requests
[81, 64, 49]
&gt;&gt;&gt; list(map(f, [7, 9]))  # Cache hits
[49, 81]
&gt;&gt;&gt; list(f.cache.values())
[16, 64, 49, 81]
&gt;&gt;&gt; set(f.requests).isdisjoint(f.cache)
True</comment>
            </section>
        </section>
        <section ids="userdict-objects" names="userdict\ objects">
            <title>UserDict objects</title>
            <paragraph>The class, UserDict acts as a wrapper around dictionary objects.
                The need for this class has been partially supplanted by the ability to
                subclass directly from dict; however, this class can be easier
                to work with because the underlying dictionary is accessible as an
                attribute.</paragraph>
            <index entries="['single',\ 'UserDict\ (class\ in\ collections)',\ 'collections.UserDict',\ '',\ None]"></index>
            <desc classes="py class" desctype="class" domain="py" noindex="False" objtype="class">
                <desc_signature class="" classes="sig sig-object py sig sig-object" fullname="UserDict" ids="collections.UserDict" module="collections"><desc_annotation xml:space="preserve">class<desc_sig_space classes="w w">  </desc_sig_space></desc_annotation><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">collections.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">UserDict</desc_name><desc_parameterlist xml:space="preserve"><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">initialdata</desc_sig_name></desc_parameter></desc_optional></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Class that simulates a dictionary.  The instance’s contents are kept in a
                        regular dictionary, which is accessible via the data attribute of
                        UserDict instances.  If <emphasis>initialdata</emphasis> is provided, data is
                        initialized with its contents; note that a reference to <emphasis>initialdata</emphasis> will not
                        be kept, allowing it to be used for other purposes.</paragraph>
                    <paragraph>In addition to supporting the methods and operations of mappings,
                        UserDict instances provide the following attribute:</paragraph>
                    <index entries="['single',\ 'data\ (collections.UserDict\ attribute)',\ 'collections.UserDict.data',\ '',\ None]"></index>
                    <desc classes="py attribute" desctype="attribute" domain="py" noindex="False" objtype="attribute">
                        <desc_signature class="UserDict" classes="sig sig-object py sig sig-object" fullname="UserDict.data" ids="collections.UserDict.data" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">data</desc_name></desc_signature>
                        <desc_content>
                            <paragraph>A real dictionary used to store the contents of the UserDict
                                class.</paragraph>
                        </desc_content>
                    </desc>
                </desc_content>
            </desc>
        </section>
        <section ids="userlist-objects" names="userlist\ objects">
            <title>UserList objects</title>
            <paragraph>This class acts as a wrapper around list objects.  It is a useful base class
                for your own list-like classes which can inherit from them and override
                existing methods or add new ones.  In this way, one can add new behaviors to
                lists.</paragraph>
            <paragraph>The need for this class has been partially supplanted by the ability to
                subclass directly from list; however, this class can be easier
                to work with because the underlying list is accessible as an attribute.</paragraph>
            <index entries="['single',\ 'UserList\ (class\ in\ collections)',\ 'collections.UserList',\ '',\ None]"></index>
            <desc classes="py class" desctype="class" domain="py" noindex="False" objtype="class">
                <desc_signature class="" classes="sig sig-object py sig sig-object" fullname="UserList" ids="collections.UserList" module="collections"><desc_annotation xml:space="preserve">class<desc_sig_space classes="w w">  </desc_sig_space></desc_annotation><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">collections.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">UserList</desc_name><desc_parameterlist xml:space="preserve"><desc_optional xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">list</desc_sig_name></desc_parameter></desc_optional></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Class that simulates a list.  The instance’s contents are kept in a regular
                        list, which is accessible via the data attribute of UserList
                        instances.  The instance’s contents are initially set to a copy of <emphasis>list</emphasis>,
                        defaulting to the empty list [].  <emphasis>list</emphasis> can be any iterable, for
                        example a real Python list or a UserList object.</paragraph>
                    <paragraph>In addition to supporting the methods and operations of mutable sequences,
                        UserList instances provide the following attribute:</paragraph>
                    <index entries="['single',\ 'data\ (collections.UserList\ attribute)',\ 'collections.UserList.data',\ '',\ None]"></index>
                    <desc classes="py attribute" desctype="attribute" domain="py" noindex="False" objtype="attribute">
                        <desc_signature class="UserList" classes="sig sig-object py sig sig-object" fullname="UserList.data" ids="collections.UserList.data" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">data</desc_name></desc_signature>
                        <desc_content>
                            <paragraph>A real list object used to store the contents of the
                                UserList class.</paragraph>
                        </desc_content>
                    </desc>
                </desc_content>
            </desc>
            <paragraph><strong>Subclassing requirements:</strong> Subclasses of UserList are expected to
                offer a constructor which can be called with either no arguments or one
                argument.  List operations which return a new sequence attempt to create an
                instance of the actual implementation class.  To do so, it assumes that the
                constructor can be called with a single parameter, which is a sequence object
                used as a data source.</paragraph>
            <paragraph>If a derived class does not wish to comply with this requirement, all of the
                special methods supported by this class will need to be overridden; please
                consult the sources for information about the methods which need to be provided
                in that case.</paragraph>
        </section>
        <section ids="userstring-objects" names="userstring\ objects">
            <title>UserString objects</title>
            <paragraph>The class, UserString acts as a wrapper around string objects.
                The need for this class has been partially supplanted by the ability to
                subclass directly from str; however, this class can be easier
                to work with because the underlying string is accessible as an
                attribute.</paragraph>
            <index entries="['single',\ 'UserString\ (class\ in\ collections)',\ 'collections.UserString',\ '',\ None]"></index>
            <desc classes="py class" desctype="class" domain="py" noindex="False" objtype="class">
                <desc_signature class="" classes="sig sig-object py sig sig-object" fullname="UserString" ids="collections.UserString" module="collections"><desc_annotation xml:space="preserve">class<desc_sig_space classes="w w">  </desc_sig_space></desc_annotation><desc_addname classes="sig-prename descclassname sig-prename descclassname" xml:space="preserve">collections.</desc_addname><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">UserString</desc_name><desc_parameterlist xml:space="preserve"><desc_parameter xml:space="preserve"><desc_sig_name classes="n n">seq</desc_sig_name></desc_parameter></desc_parameterlist></desc_signature>
                <desc_content>
                    <paragraph>Class that simulates a string object.  The instance’s
                        content is kept in a regular string object, which is accessible via the
                        data attribute of UserString instances.  The instance’s
                        contents are initially set to a copy of <emphasis>seq</emphasis>.  The <emphasis>seq</emphasis> argument can
                        be any object which can be converted into a string using the built-in
                        str() function.</paragraph>
                    <paragraph>In addition to supporting the methods and operations of strings,
                        UserString instances provide the following attribute:</paragraph>
                    <index entries="['single',\ 'data\ (collections.UserString\ attribute)',\ 'collections.UserString.data',\ '',\ None]"></index>
                    <desc classes="py attribute" desctype="attribute" domain="py" noindex="False" objtype="attribute">
                        <desc_signature class="UserString" classes="sig sig-object py sig sig-object" fullname="UserString.data" ids="collections.UserString.data" module="collections"><desc_name classes="sig-name descname sig-name descname" xml:space="preserve">data</desc_name></desc_signature>
                        <desc_content>
                            <paragraph>A real str object used to store the contents of the
                                UserString class.</paragraph>
                        </desc_content>
                    </desc>
                    <versionmodified type="versionchanged" version="3.5"><paragraph translatable="False">Changed in version 3.5: New methods __getnewargs__, __rmod__, casefold,
                            format_map, isprintable, and maketrans.</paragraph></versionmodified>
                </desc_content>
            </desc>
        </section>
    </section>
</document>
